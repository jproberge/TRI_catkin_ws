/*
 * This is part of the fl library, a C++ Bayesian filtering library
 * (https://github.com/filtering-library)
 *
 * Copyright (c) 2015 Max Planck Society,
 * 				 Autonomous Motion Department,
 * 			     Institute for Intelligent Systems
 *
 * This Source Code Form is subject to the terms of the MIT License (MIT).
 * A copy of the license can be found in the LICENSE file distributed with this
 * source code.
 */

/**
 * \file sigma_point_quadrature.hpp
 * \date July 2015
 * \author Jan Issac (jan.issac@gmail.com)
 */

#pragma once

#include <fl/util/meta.hpp>
#include <fl/util/traits.hpp>
#include <fl/util/descriptor.hpp>
#include <fl/distribution/gaussian.hpp>
#include <fl/filter/gaussian/transform/point_set.hpp>

namespace fl
{
/**
 * \ingroup numeric_integration
 *
 * \brief Represents a numeric integration tool based on sigma point selections
 *        of Gaussian distribution
 *
 * ## Examples: Expectation computation ##
 *
 * ### Computing the first moment (mean) ####
 * \f$\mathbb{E}[f(x)] = \displaystyle\int f(x) p(x) \mathrm{d}x\f$
 *
 * \code
 * typedef Eigen::Vector<Real, 10> MyVariate;
 *
 * MyVariate some_function(const MyVariate& x) { return ...; }
 *
 * ...
 *
 * // setup a gaussian distribution
 * Gaussian<MyVariate> p;
 * p.mean(MyVariate::Random(10));
 * p.covariance(p.covariance() * std::rand());
 *
 * // create the lambda we will pass to the integrator
 * auto f = [&](const MyVariate& x) -> MyVariate { return some_function(x); };
 *
 * auto f_mean = integrate(f, p);
 * \endcode
 *
 * ### Computing the second centered moment (covariance) ###
 * \f$\begin{align} \mathbb{Cov}[f(x)]
 *    & = \mathbb{E}[(f(x)-\mathbb{E}[f(x)])^2] \\
 *    & = \displaystyle\int
 *        \underbrace{\left(f(x)-\mu_f\right)\left(f(x)-\mu_f\right)^T}_{g(x):=}
 *        p(x) \mathrm{d}x \\
 *    & = \displaystyle\int g(x) p(x) \mathrm{d}x
 * \end{align}
 * \f$
 *
 * \code
 * // ... continuing the code from the previous example above
 *
 * typedef typename Gaussian<MyVariate>::SecondMoment SecondMoment;
 *
 * // create the quadratic form (f(x)-mu_f)(f(x)-mu_f)^T lambda we will pass
 * // to the integrator
 * auto g = [&](int x) -> SecondMoment
 * {
 *     return (some_function(x) - f_mean) *
 *            (some_function(x) - f_mean).transpose();
 * };
 * auto f_covariance = integrate(g, p);
 *
 *
 * \endcode
 */
template <typename Transform>
class SigmaPointQuadrature : Descriptor
{
   public:
    /**
     * \brief Creates a SigmaPointQuadrature
     */
    template <typename... Args>
    SigmaPointQuadrature(Args... args)
        : transform_(args...)
    {
    }

    /**
     * \brief Creates a SigmaPointQuadrature
     *
     * \param transform
     *              Transform instance, e.g. UnscentedTrasnform or
     *              MonteCarloTransform
     */
    explicit SigmaPointQuadrature(const Transform& transform)
        : transform_(transform)
    {
    }

    /**
     * \brief Returns the number of points generated by transform
     *
     * \param dimension Dimension of the Gaussian
     */
    static constexpr int number_of_points(int dimension)
    {
        return Transform::number_of_points(dimension);
    }

    /**
     * \brief Returns the compile time number of points generated by transform
     */
    template <typename... Variates>
    static constexpr int number_of_points()
    {
        return number_of_points(JoinSizes<SizeOf<Variates>::Value...>::Size);
    }

    /**
     * \brief Returns the compile time number of points generated by transform.
     * This is a shorthand alias to \a number_of_points<...>()
     *
     * \note GCC 4.6 does not support yet constexpr function calls within
     * template arguments. use \a Size<>::Value instead.
     */
    template <typename... Variates>
    static constexpr int size()
    {
        return number_of_points(JoinSizes<SizeOf<Variates>::Value...>::Size);
    }

    /**
     * \brief Returns the compile time number of points generated by transform.
     * This is a shorthand alias to \a number_of_points<...>()
     */
    template <typename... Variates>
    struct Size
    {
        enum : signed int
        {
            Value = Transform::number_of_points(
                JoinSizes<SizeOf<Variates>::Value...>::Value)
        };
    };

    /** @{ */

    /**
     * \brief Integration function performing integrals of the form
     *        \f$
     *         \displaystyle\int f(x) p(x) \mathrm{d}x
     *        \f$.
     *
     * \f$p(x)\f$ is a Gaussian distribution \f${\cal N}(x; \mu_x, \Sigma_x)\f$.
     *
     * \tparam Integrand
     *              \a Integrand callable type of \f$f(x)\f$.
     *              \a Integrand is either a lambda or a functor
     * \tparam Variate
     *              Variate type of the Gaussian distribuion \f$p(x)\f$
     *
     * \param [in] f
     *              Integrand lambda or functor \f$\f$
     * \param [in] distr
     *              Gaussian distribution of the integral
     *
     * \return integration result which has the type of the specified Integrand.
     *
     * \note   This integrator is quite generic. However, it can be quite
     *         inefficient since it doesn't make any assumptions on the
     *         integration result type. It is recommanded to be used in
     *         educational and prototyping purposes only.
     *         Use propergate_gaussian() or integrate_moments() for higher
     *         efficiency.
     */
    template <typename Integrand, typename Variate>
    auto integrate(Integrand&& f, const Gaussian<Variate>& distr)
        -> decltype(f(Variate()))
    {
        const int point_count = number_of_points(distr.dimension());

        auto X = PointSet<Variate, Size<Variate>::Value>(distr.dimension(),
                                                         point_count);

        transform_(distr, X);

        auto E = f(X[0]);
        E *= X.weight(0);

        for (int i = 1; i < point_count; ++i) E += X.weight(i) * f(X[i]);

        return E;
    }

    /**
     * \brief Integration function performing integrals of the form \n
     * \f$
     * \begin{align}
     *  \int_x\int_y f(x, y) p(x, y) \mathrm{d}y\mathrm{d}x
     *    = \int_x\int_y f(x, y) p(y\mid x) p(x)\mathrm{d}y\mathrm{d}x
     * \end{align}
     * \f$.
     *
     * \f$p(x)\f$ and \f$p(y\mid x)\f$ are the marginal Gaussian distributions
     * \f${\cal N}(x; \mu_x, \Sigma_x)\f$ and
     * \f${\cal N}(y; \mu_{y|x}, \Sigma_{y|x})\f$, repsectively.
     *
     * \tparam Integrand
     *              Integrand callable type of \f$f(x, y)\f$
     * \tparam VarA
     *              Variate type \f$x\f$ of the Gaussian \f$p(x, y)\f$
     * \tparam VarB
     *              Variate type \f$y\f$ of the Gaussian \f$p(x, y)\f$
     *
     * \param [in] f
     *              Integrand lambda or functor \f$\f$
     * \param [in] marginal_gaussian_a
     *              First marginal Gaussian distribution
     * \param [in] marginal_gaussian_b
     *              Second marginal Gaussian distribution
     *
     * \return integration result which has the return type of the \a Integrand.
     *
     * \note   This integrator is quite generic. However, it can be quite
     *         inefficient since it doesn't make any assumptions on the
     *         integration result type. It is recommanded to be used in
     *         educational and prototyping purposes only.
     *         Use propergate_gaussian() or integrate_moments() for higher
     *         efficiency.
     */
    template <typename Integrand, typename VariateA, typename VariateB>
    auto integrate(Integrand&& f,
                   const Gaussian<VariateA>& marginal_gaussian_a,
                   const Gaussian<VariateB>& marginal_gaussian_b)
        -> decltype(f(VariateA(), VariateB()))
    {
        enum : signed int
        {
            Points = Size<VariateA, VariateB>::Value
        };

        const int dim_a = marginal_gaussian_a.dimension();
        const int dim_b = marginal_gaussian_b.dimension();
        const int augmented_dim = dim_a + dim_b;
        const int point_count = number_of_points(augmented_dim);

        auto X_a = PointSet<VariateA, Points>(dim_a, point_count);
        auto X_b = PointSet<VariateB, Points>(dim_b, point_count);

        transform_(marginal_gaussian_a, augmented_dim, 0, X_a);

        transform_(marginal_gaussian_b, augmented_dim, dim_a, X_b);

        auto E = f(X_a[0], X_b[0]);
        E *= X_a.weight(0);
        for (int i = 1; i < point_count; ++i)
        {
            E += X_a.weight(i) * f(X_a[i], X_b[i]);
        }

        return E;
    }

    /** @} */

    /** @{ */

    /**
     * \brief Integration function performing integrals of the form
     *        \f$
     *         \displaystyle\int f(x) p(x) \mathrm{d}x
     *        \f$.
     *
     * \f$p(x)\f$ is a Gaussian distribution \f${\cal N}(x; \mu_x, \Sigma_x)\f$.
     *
     * \tparam Integrand
     *              \a Integrand function type of \f$f(x)\f$.
     *              \a Integrand is either a \c lambda or a functor
     * \tparam Variate
     *              Variate type of the Gaussian distribuion \f$p(x)\f$
     *
     * \param [in] f
     *              Integrand lambda or functor \f$\f$
     * \param [in] distr
     *              Gaussian distribution of the integral
     * \param [out] Z
     *              Integration result which is represented as a set of
     *              points of type PointSet. The first two moments of
     *              the point set can be used to represent a fitted
     *              Gaussian of the integral result.
     */
    template <typename Integrand, typename Variate>
    void propergate_gaussian(
        Integrand&& f,
        const Gaussian<Variate>& distr,
        PointSet<decltype(f(Variate())), Size<Variate>::Value>& Z) const
    {
        PointSet<Variate, Size<Variate>::Value> Y;
        propergate_gaussian(f, distr, Y, Z);
    }

    /**
     * \brief Integration function performing integrals of the form
     *        \f$
     *         \displaystyle\int f(x) p(x) \mathrm{d}x
     *        \f$.
     *
     * \f$p(x)\f$ is a Gaussian distribution \f${\cal N}(x; \mu_x, \Sigma_x)\f$.
     *
     * The \a PointSet \a X stores the selected quarature points of the input
     * Gaussian used in the integration. This set is particularly helpful
     * when computing the cross-covariance between the input random variable and
     * the Integrand variate, i.e \f$\mathbb{Cov}[X,f(X)]\f$.
     *
     * Sampe code of computing the cross-covariance
     * \code
     * auto X_c = X.centered_points();
     * auto Z_c = Z.centered_points()
     * auto W = X.covariance_weight_vector();
     * auto cov_xy = (X_c * W.asDiagonal() * Z_c.transpose()).eval();
     * \endcode
     *
     * \tparam Integrand
     *              \a Integrand callable type of \f$f(x)\f$.
     *              \a Integrand is either a lambda or a functor
     * \tparam Variate
     *              Variate type of the Gaussian distribuion \f$p(x)\f$
     *
     * \param [in]  f
     *              Integrand lambda or functor \f$\f$
     * \param [in]  distr
     *              Gaussian distribution of the integral
     * \param [out] X
     *              Stores the selected quarature points of the input
     *              Gaussian used in the integration.
     * \param [out] Z
     *              Integration result which is represented as a set of
     *              points of type PointSet. The first two moments of
     *              the point set can be used to represent a fitted
     *              Gaussian of the integral result.
     */
    template <typename Integrand, typename Variate>
    void propergate_gaussian(
        Integrand&& f,
        const Gaussian<Variate>& distr,
        PointSet<Variate, Size<Variate>::Value>& X,
        PointSet<decltype(f(Variate())), Size<Variate>::Value>& Z) const
    {
        const int point_count = number_of_points(distr.dimension());

        X.resize(distr.dimension(), point_count);

        transform_(distr, X);

        auto p0 = f(X[0]);
        Z.resize(p0.size(), point_count);
        Z.point(0, p0, X.weights(0).w_mean, X.weights(0).w_cov);

        for (int i = 1; i < point_count; ++i)
        {
            Z.point(i, f(X[i]), X.weights(i).w_mean, X.weights(i).w_cov);
        }
    }

    /**
     * \brief Integration function performing integrals of the form \n
     * \f$
     * \begin{align}
     *  \int_x\int_y f(x, y) p(x, y) \mathrm{d}y\mathrm{d}x
     *    = \int_x\int_y f(x, y) p(y\mid x) p(x)\mathrm{d}y\mathrm{d}x
     * \end{align}
     * \f$.
     *
     * \f$p(x)\f$ and \f$p(y\mid x)\f$ are the marginal Gaussian distributions
     * \f${\cal N}(x; \mu_x, \Sigma_x)\f$ and
     * \f${\cal N}(y; \mu_{y|x}, \Sigma_{y|x})\f$, repsectively.
     *
     * The \a GaussianPointSet \a X stores the selected quarature points of the
     * input Gaussian used in the integration. This set is particularly helpful
     * when computing the cross-covariance between the input random variable and
     * the Integrand variate, i.e \f$\mathbb{Cov}[X,f(X)]\f$.
     *
     * Sampe code of computing the cross-covariance
     * \code
     * auto X_c = X.centered_points();
     * auto Z_c = Z.centered_points()
     * auto W = X.covariance_weight_vector();
     * auto cov_xy = (X_c * W.asDiagonal() * Z_c.transpose()).eval();
     * \endcode
     *
     * \tparam Integrand
     *              Integrand function type of \f$f(x, y)\f$
     * \tparam VarA
     *              Variate type \f$x\f$ of the Gaussian \f$p(x, y)\f$
     * \tparam VarB
     *              Variate type \f$y\f$ of the Gaussian \f$p(x, y)\f$
     *
     * \param [in] f
     *              Integrand lambda or functor \f$\f$
     * \param [in] marginal_gaussian_a
     *              First marginal Gaussian distribution
     * \param [in] marginal_gaussian_b
     *              Second marginal Gaussian distribution
     * \param [out] Z
     *              Integration result which is represented as a set of
     *              points of type PointSet. The first two moments of
     *              the point set can be used to represent a fitted
     *              Gaussian of the integral result.
     */
    template <typename Integrand, typename VarA, typename VarB>
    void propergate_gaussian(
        Integrand&& f,
        const Gaussian<VarA>& marginal_gaussian_a,
        const Gaussian<VarB>& marginal_gaussian_b,
        PointSet<decltype(f(VarA(), VarB())), Size<VarA, VarB>::Value>& Z) const
    {
        PointSet<VarA, Size<VarA, VarB>::Value> X;
        PointSet<VarB, Size<VarA, VarB>::Value> Y;
        propergate_gaussian(
            f, marginal_gaussian_a, marginal_gaussian_b, X, Y, Z);
    }

    /**
     * \brief Integration function performing integrals of the form \n
     * \f$
     * \begin{align}
     *  \int_x\int_y f(x, y) p(x, y) \mathrm{d}y\mathrm{d}x
     *    = \int_x\int_y f(x, y) p(y\mid x) p(x)\mathrm{d}y\mathrm{d}x
     * \end{align}
     * \f$.
     *
     * \f$p(x)\f$ and \f$p(y\mid x)\f$ are the marginal Gaussian distributions
     * \f${\cal N}(x; \mu_x, \Sigma_x)\f$ and
     * \f${\cal N}(y; \mu_{y|x}, \Sigma_{y|x})\f$, repsectively.
     *
     * The \a GaussianPointSet \a X stores the selected quarature points of the
     * input Gaussian used in the integration. This set is particularly helpful
     * when computing the cross-covariance between the input random variable and
     * the Integrand variate, i.e \f$\mathbb{Cov}[X,f(X)]\f$.
     *
     * Sampe code of computing the cross-covariance
     * \code
     * auto X_c = X.centered_points();
     * auto Z_c = Z.centered_points()
     * auto W = X.covariance_weight_vector();
     * auto cov_xy = (X_c * W.asDiagonal() * Z_c.transpose()).eval();
     * \endcode
     *
     * \tparam Integrand
     *              Integrand function type of \f$f(x, y)\f$
     * \tparam VarA
     *              Variate type \f$x\f$ of the Gaussian \f$p(x, y)\f$
     * \tparam VarB
     *              Variate type \f$y\f$ of the Gaussian \f$p(x, y)\f$
     *
     * \param [in] f
     *              Integrand lambda or functor \f$\f$
     * \param [in] marginal_gaussian_a
     *              First marginal Gaussian distribution
     * \param [in] marginal_gaussian_b
     *              Second marginal Gaussian distribution
     * \param [out] X
     *              Stores the selected quarature points of the input marginal
     *              Gaussian<VarA> used in the integration.
     * \param [out] Y
     *              Stores the selected quarature points of the input marginal
     *              Gaussian<VarB> used in the integration.
     * \param [out] Z
     *              Integration result which is represented as a set of
     *              points of type PointSet. The first two moments of
     *              the point set can be used to represent a fitted
     *              Gaussian of the integral result.
     */
    template <typename Integrand, typename VarA, typename VarB>
    void propergate_gaussian(
        Integrand&& f,
        const Gaussian<VarA>& marginal_gaussian_a,
        const Gaussian<VarB>& marginal_gaussian_b,
        PointSet<VarA, Size<VarA, VarB>::Value>& X,
        PointSet<VarB, Size<VarA, VarB>::Value>& Y,
        PointSet<decltype(f(VarA(), VarB())), Size<VarA, VarB>::Value>& Z) const
    {
        transform_to_points(marginal_gaussian_a, marginal_gaussian_b, X, Y);
        propagate_points(f, X, Y, Z);
    }

    template <typename VarA, typename VarB>
    void transform_to_points(const Gaussian<VarA>& marginal_gaussian_a,
                             const Gaussian<VarB>& marginal_gaussian_b,
                             PointSet<VarA, Size<VarA, VarB>::Value>& X,
                             PointSet<VarB, Size<VarA, VarB>::Value>& Y) const
    {
        const int dim_a = marginal_gaussian_a.dimension();
        const int dim_b = marginal_gaussian_b.dimension();

        const int augmented_dim = dim_a + dim_b;
        const int point_count = Transform::number_of_points(augmented_dim);

        X.resize(dim_a, point_count);
        Y.resize(dim_b, point_count);

        transform_(marginal_gaussian_a, augmented_dim, 0, X);
        transform_(marginal_gaussian_b, augmented_dim, dim_a, Y);
    }

    template <typename Integrand,
              typename PointSetX,
              typename PointSetY,
              typename PointSetZ>
    void propagate_points(Integrand&& f,
                          PointSetX& X,
                          PointSetY& Y,
                          PointSetZ& Z) const
    {
        const int point_count = X.count_points();

        auto p0 = f(X[0], Y[0]);
        Z.resize(p0.size(), point_count);
        Z.point(0, p0, X.weights(0).w_mean, X.weights(0).w_cov);

        for (int i = 1; i < point_count; ++i)
        {
            auto y = f(X[i], Y[i]);
            Z.point(i, y, X.weights(i).w_mean, X.weights(i).w_cov);
        }
    }

    /**
     * \brief Integration function performing two integrations at once
     *        computing the expectation of the first two moments\n
     *        \f$
     *        \begin{align}
     *            \mathrm{mean} & \approx \mathbb{E}[f(x)]
     *                = \int_x f(x) p(x) \mathrm{d}x
     *        \end{align}
     *        \f$
     *  \n and \n
     *        \f$
     *        \begin{align}
     *            \mathrm{cov} & \approx \mathbb{Cov}[f(x)]
     *                = \displaystyle\int_x
     *                \left(f(x)-\mu_f\right)\left(f(x)-\mu_f\right)^T
     *               p(x) \mathrm{d}x
     *        \end{align}
     *        \f$
     * \n
     * with \f$\mu_f = \mathrm{mean}\f$.
     *
     * \tparam Integrand
     *              \a Integrand callable type of \f$f(x)\f$.
     *              \a Integrand is either a lambda or a functor
     * \tparam Variate
     *              Variate type of the Gaussian distribuion \f$p(x)\f$
     *
     * \param [in]  f
     *              Integrand lambda or functor \f$\f$
     * \param [in]  distr
     *              Gaussian distribution of the integral
     *
     * \param [out] mean
     *              Integrated first moment \f$\mathbb{E}[f(x)]\f$.
     * \param [out] cov
     *              Integrated second centered moment \f$\mathbb{Cov}[f(x)]\f$.
     */
    template <typename Integrand, typename Variate>
    void integrate_moments(
        Integrand&& f,
        const Gaussian<Variate>& distr,
        typename FirstMomentOf<decltype(f(Variate()))>::Type& mean,
        typename SecondMomentOf<decltype(f(Variate()))>::Type& cov) const
    {
        auto Z = PointSet<decltype(f(Variate())), Size<Variate>::Value>();
        propergate_gaussian(f, distr, Z);

        mean = Z.center();
        auto&& Z_c = Z.points();
        auto&& W = Z.covariance_weights_vector();
        cov = Z_c * W.asDiagonal() * Z_c.transpose();
    }

    /**
     * \brief Integration function performing two double integrations at once
     *        computing the expectation of the first two moments\n
     * \f$
     *   \begin{align}
     *     \mathrm{mean} \approx \mathbb{E}[f(x)]
     *       & = \int_x \int_y f(x, y) p(x, y) \mathrm{d}y\mathrm{d}x \\
     *       & = \int_x \int_y f(x, y) p(y\mid x) p(x) \mathrm{d}y\mathrm{d}x
     *   \end{align}
     * \f$
     *  \n and \n
     * \f$
     *   \begin{align}
     *     \mathrm{cov} \approx \mathbb{Cov}[f(x)]
     *       & = \displaystyle\int_x \int_y
     *             \left(f(x, y)-\mu_f\right)\left(f(x, y)-\mu_f\right)^T
     *             p(x, y) \mathrm{d}y\mathrm{d}x \\
     *       & = \displaystyle\int_x \int_y
     *             \left(f(x, y)-\mu_f\right)\left(f(x, y)-\mu_f\right)^T
     *             p(y\mid x) p(x) \mathrm{d}y\mathrm{d}x
     *   \end{align}
     * \f$
     * \n
     * with \f$\mu_f = \mathrm{mean}\f$.
     *
     * \tparam Integrand
     *              \a Integrand callable type of \f$f(x)\f$.
     *              \a Integrand is either a lambda or a functor
     * \tparam VarA
     *              Variate type \f$x\f$ of the Gaussian \f$p(x, y)\f$
     * \tparam VarB
     *              Variate type \f$y\f$ of the Gaussian \f$p(x, y)\f$
     *
     * \param [in]  f
     *              Integrand lambda or functor \f$\f$
     * \param [in]  distr
     *              Gaussian distribution of the integral
     *
     * \param [out] mean
     *              Integrated first moment \f$\mathbb{E}[f(x,y)]\f$.
     * \param [out] cov
     *              Integrated second centered moment
     * \f$\mathbb{Cov}[f(x,y)]\f$.
     */
    template <typename Integrand, typename VarA, typename VarB>
    void integrate_moments(
        Integrand&& f,
        const Gaussian<VarA>& marginal_gaussian_a,
        const Gaussian<VarB>& marginal_gaussian_b,
        typename FirstMomentOf<decltype(f(VarA(), VarB()))>::Type& mean,
        typename SecondMomentOf<decltype(f(VarA(), VarB()))>::Type& cov) const
    {
        enum : signed int
        {
            NumberOfPoints = Size<VarA, VarB>::Value
        };

        static_assert(NumberOfPoints != 0,
                      "NumberOfPoints must not evaluate to 0");

        auto X = PointSet<VarA, NumberOfPoints>();
        auto Y = PointSet<VarB, NumberOfPoints>();
        auto Z = PointSet<decltype(f(VarA(), VarB())), NumberOfPoints>();

        propergate_gaussian(
            f, marginal_gaussian_a, marginal_gaussian_b, X, Y, Z);

        mean = Z.center();
        auto&& Z_c = Z.points();
        auto&& W = Z.covariance_weights_vector();
        cov = Z_c * W.asDiagonal() * Z_c.transpose();
    }

    /** @} */

    /** @{ */

    /**
     * \brief Returns a reference to the trandform used internally to generate
     *        the points or samples from the gaussian distributions
     */
    Transform& transform() { return transform_; }
    /**
     * \brief Returns a const reference to the trandform used internally to
     *        generate the points or samples from the gaussian distributions
     */
    const Transform& transform() const { return transform_; }
    virtual std::string name() const
    {
        return "SigmaPointQuadrature<" + list_arguments(transform().name()) +
               ">";
    }

    virtual std::string description() const
    {
        return "Sigma Point based numerical quadrature using :" +
               indent(transform().description());
    }

    /** @} */

   protected:
    Transform transform_;
};
}
